### 정적 생성의 장점

사이트 접속 시 빌드 과정 중 렌더링이 다 된 파일이 불러와지기 때문에 별도의 렌더링 과정을 거치지 않고 빠르게 페이지를 확인할 수 있습니다

ex) 블로그 : 새 블로그 게시물을 추가할 때마다 프로젝트를 다시 사전 생성할 수 있습니다.
npm run build를 실행하고 업데이트된 프로젝트를 배포하면 됩니다.

<aside>
💡 그러나 더 자주 바뀌는 데이터가 존재하는 페이지에서는 적합하지 않습니다

</aside>

## 첫번째 해결책

페이지를 사전 빌드하지만 서버에서 업데이트된 데이터 페칭을 위해 useEffect를 사용하는 React컴포넌트에 표준 React 컴포넌트를 포함하는 것.

즉, 항상 사전 렌더링 된 데이터를 일부 포함해 페이지를 제공하지만 데이터는 오래됐을 수 있으니 백그라운드에서 최신 데이터를 페칭해서 그 데이터가 도착한 후에 로드된 페이지를 업데이트 하는 것

⇒ 사용자에게 처음부터 페이지의 일부 데이터가 나타나지만 오래된 데이터일 수 있기 때문에 가장 최신의 데이터로 페이지를 업데이트할 수 있도록 백그라운드에서 데이터를 가져오는 겁니다.

## 증분 정적 생성(ISR : Incremental Static Generation)

페이지를 빌드할 때 정적으로 한 번만 생성하는게 아니라 배포 후에도 재배포 없이 계속 업데이트된다는 뜻입니다.

⇒ 페이지를 사전 생성을 하긴 하지만 최대 X초마다 들어오는 모든 요청에 대해 주어진 페이지를 Next.js 가 재생성 하도록 할 수 있습니다. 가령 60초 마다라고 하면 특정 페이지에 대한 요청이 있고, 가령 마지막으로 재생성된 후 60초가 지나지 않았다면 기존 페이지가 방문자에게 제공된다는 뜻입니다. 시간은 정하기 나름입니다. 페이지는 서버에서 사전 생성되고 업데이트됩니다. 오래되지 않으면 이전 페이지를 제공하고 시간이 지나면 서버에서 재생성된 가장 최신의 페이지를 제공한다는 의미입니다.

페이지가 오래되어서 사전 생성되면 새로 생성된 이 페이지는 서버에 있던 오래된 기존 페이지를 대체하고 캐시되며 향후 방문자는 재생성된 페이지를 보게 됩니다.

따라서 들어오는 요청에 대해 서버에서 사전 렌더링을 계속 수행할 수 있고, 이를 수행하기 위해서는

기존의 **fetch 함수에 cache 속성값을 변경해주면 됩니다**. 아래와 같이코드를 사용하면

**10초마다 캐시를 갱신한다는 뜻**입니다.

```jsx
fetch(URL, { next: { revalidate: 10 } });
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ae098ee2-820a-40b8-a80f-961610b6b0ee/74307386-ada2-47a8-80c6-38fc379d9f69/Untitled.png)

### 서버 사이드 렌더링
